/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package solution;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import solution.Solution.ListNode;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

class SolutionTest {
    // Class that saves and verifies merged list pointers and values:
    class Pointers {
        Set<ListNode> pointerSet = new HashSet<>();

        void saveList(ListNode list) {
            ListNode curr = list;
            while (curr != null) {
                pointerSet.add(curr);
                curr = curr.next;
            }
        }

        // Remove the resultNodes 'ListNode's from the 'pointerSet' while validating the
        // values against the expected values.
        // Finally check if all 'ListNode's have been removed.
        void verify(ListNode resultNodes, int[] expectedValues) {
            ListNode currResultNode = resultNodes;

            for (int i = 0; i < expectedValues.length; i++) {

                assertTrue(currResultNode != null,
                        "*** TEST FAIL: Resulting merged list is shorter than the length of provided 'expected[]' ***");

                assertTrue(currResultNode.val == expectedValues[i],
                        "*** TEST FAIL: ListNode value doesn't match the provided expected value. Expected value: "
                                + expectedValues[i] + ", Resulting Value: " + currResultNode.val + " ***");

                assertTrue(pointerSet.remove(currResultNode),
                        "*** TEST FAIL: ListNode value matches expected, but the ListNode object doesn't belong to either one of the original lists. ***");
                currResultNode = currResultNode.next;

            }

            assertTrue(pointerSet.isEmpty(), "*** Fail: Unvalidated nodes remain ***");
        }

    }

    // MyListNode class for parsing CsvSource to instantiating the lists:
    static class MyListNode {
        private final List<Integer> valueList = new ArrayList<>();
        public final int[] values;
        public final ListNode head;

        MyListNode(String s) {
            String[] tokens = s.split(";");
            int n = tokens.length;

            head = new ListNode(Integer.parseInt(tokens[0]));

            ListNode curr = head;

            for (int i = 1; i < n; ++i) {
                curr.next = new ListNode(Integer.parseInt(tokens[i]));
                valueList.add(Integer.parseInt(tokens[i]));
                curr = curr.next;
            }

            values = new int[valueList.size()];
            for (int i = 0; i < valueList.size(); i++) {
                values[i] = valueList.get(i);
            }
        }
    }

    // MyArr class for parsing CsvSource to 'int[]' array.
    static class MyArr {
        final int[] values;

        MyArr(String s) {
            String[] tokens = s.split(";");
            int n = tokens.length;

            values = new int[n];
            for (int i = 0; i < n; ++i) {
                values[i] = Integer.parseInt(tokens[i]);
            }
        }
    }

    void verifyListValuesAreEqual(ListNode a, ListNode b) {
    }

    // ***Below is a more industry aligned testing approach:***

    // First test values:
    @ParameterizedTest
    @CsvSource({
            "1;2;4, 1;3;4, 1;1;2;3;4;4",
    })
    void mergeProducesValuesInCorrectOrder(MyListNode list1, MyListNode list2, MyListNode expected) {
        ListNode result = (new Solution()).mergeTwoLists(list1.head, list2.head);

        ListNode aCurr = expected.head;
        ListNode bCurr = result;
        while (aCurr != null && bCurr != null) {
            assertEquals(aCurr.val, bCurr.val);
            aCurr = aCurr.next;
            bCurr = bCurr.next;
        }
        assertNull(aCurr);
        assertNull(bCurr);
    }

    // Then test objects (using .hashCode()):
    @ParameterizedTest
    @CsvSource({
            "1;2;4, 1;3;4, 1;1;2;3;4;4",
    })
    void mergedListIsMadeOfElementsOfInputLists(MyListNode list1, MyListNode list2, MyListNode expected) {
        int expectedHashAgg = 0;
        // There is probably a way to replace this with a method that can iterate over a
        // list and apply a function, something like this:
        //
        // applyOperation(list1, (a, b) -> {return a ^ b});
        //
        for (ListNode curr = list1.head; curr != null; curr = curr.next) {
            expectedHashAgg ^= curr.hashCode();
        }

        for (ListNode curr = list2.head; curr != null; curr = curr.next) {
            expectedHashAgg ^= curr.hashCode();
        }

        ListNode result = (new Solution()).mergeTwoLists(list1.head, list2.head);
        int actualHashAgg = 0;
        for (ListNode curr = result; curr != null; curr = curr.next) {
            actualHashAgg ^= curr.hashCode();
        }

        assertEquals(expectedHashAgg, actualHashAgg);
    }

}