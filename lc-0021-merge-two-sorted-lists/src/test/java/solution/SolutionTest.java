/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package solution;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import solution.Solution.ListNode;

import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

class SolutionTest {
    // Class that saves and verifies merged list pointers and values:
    class Pointers {
        Set<ListNode> pointerSet = new HashSet<>();

        void saveList(ListNode list) {
            ListNode curr = list;
            while (curr != null) {
                pointerSet.add(curr);
                curr = curr.next;
            }
        }

        // Remove the resultNodes 'ListNode's from the 'pointerSet' while validating the
        // values against the expected values.
        // Finally check if all 'ListNode's have been removed.
        void verify(ListNode resultNodes, int[] expectedValues) {
            ListNode currResultNode = resultNodes;

            for (int i = 0; i < expectedValues.length; i++) {

                assertTrue(currResultNode != null,
                        "*** TEST FAIL: Resulting merged list is shorter than the length of provided 'expected[]' ***");

                assertTrue(currResultNode.val == expectedValues[i],
                        "*** TEST FAIL: ListNode value doesn't match the provided expected value. Expected value: "
                                + expectedValues[i] + ", Resulting Value: " + currResultNode.val + " ***");

                assertTrue(pointerSet.remove(currResultNode),
                        "*** TEST FAIL: ListNode value matches expected, but the ListNode object doesn't belong to either one of the original lists. ***");
                currResultNode = currResultNode.next;

            }

            assertTrue(pointerSet.isEmpty(), "*** Fail: Unvalidated nodes remain ***");
        }

    }

    // MyListNode class for parsing CsvSource to instantiating the lists:
    static class MyListNode {
        private final List<Integer> valueList = new ArrayList<>();
        public final int[] values;
        public final ListNode head;

        MyListNode(String s) {
            String[] tokens = s.split(";");
            int n = tokens.length;

            head = new ListNode(Integer.parseInt(tokens[0]));

            ListNode curr = head;

            for (int i = 1; i < n; ++i) {
                curr.next = new ListNode(Integer.parseInt(tokens[i]));
                valueList.add(Integer.parseInt(tokens[i]));
                curr = curr.next;
            }

            values = new int[valueList.size()];
            for (int i = 0; i < valueList.size(); i++) {
                values[i] = valueList.get(i);
            }
        }
    }

    // MyArr class for parsing CsvSource to 'int[]' array.
    static class MyArr {
        final int[] values;

        MyArr(String s) {
            String[] tokens = s.split(";");
            int n = tokens.length;

            values = new int[n];
            for (int i = 0; i < n; ++i) {
                values[i] = Integer.parseInt(tokens[i]);
            }
        }
    }

    @ParameterizedTest
    @CsvSource({
            "1;2;4, 1;3;4, 1;1;2;3;4;4",
    })
    void testCorrect(MyListNode list1, MyListNode list2, MyArr expected) {
        Pointers p = new Pointers();
        p.saveList(list1.head);
        p.saveList(list2.head);

        Solution s = new Solution();

        ListNode result = s.mergeTwoLists(list1.head, list2.head);

        p.verify(result, expected.values);

    }

    @ParameterizedTest
    @CsvSource({
            "1;2;4, 1;3;4, 1;1;2;3;4;4",
    })
    void testDeepCopy(MyListNode list1, MyListNode list2, MyArr expected) {
        Pointers p = new Pointers();
        p.saveList(list1.head);
        p.saveList(list2.head);

        Solution s = new Solution();

        ListNode result = s.deepCopyMergeTwoLists(list1.head, list2.head);

        p.verify(result, expected.values);

    }
}
